package com.moyue.source.engine

import com.google.gson.Gson
import com.moyue.model.Book
import com.moyue.model.BookChapter
import com.moyue.model.BookSource
import com.moyue.source.JsExtensions
import org.mozilla.javascript.Context
import org.mozilla.javascript.Function
import org.mozilla.javascript.ScriptableObject
import org.springframework.stereotype.Component
import java.util.concurrent.*

@Component
class RhinoEngine(
    private val jsExtensions: JsExtensions
) {
    
    private val executor = ThreadPoolExecutor(
        2, 4, 60L, TimeUnit.SECONDS,
        LinkedBlockingQueue(20)
    )
    
    private val gson = Gson()
    
    data class ExecuteResult(
        val success: Boolean,
        val result: Any?,
        val error: String? = null,
        val executionTime: Long = 0
    ) {
        fun copy(
            success: Boolean = this.success,
            result: Any? = this.result,
            error: String? = this.error,
            executionTime: Long = this.executionTime
        ): ExecuteResult {
            return ExecuteResult(success, result, error, executionTime)
        }
    }
    
    // 通用执行方法
    fun execute(
        jsCode: String,
        functionName: String? = null,
        source: BookSource? = null,
        book: Book? = null,
        chapter: BookChapter? = null,
        vararg args: Any
    ): ExecuteResult {
        val startTime = System.currentTimeMillis()
        
        val future = executor.submit<ExecuteResult> {
            val cx = Context.enter()
            try {
                jsExtensions.setContext(JsExtensions.ExecutionContext(
                    source = source,
                    book = book,
                    chapter = chapter
                ))
                
                configureContext(cx)
                
                val scope = cx.initStandardObjects()
                
                val jsJava = Context.javaToJS(jsExtensions, scope)
                ScriptableObject.putProperty(scope, "java", jsJava)
                
                source?.let {
                    ScriptableObject.putProperty(scope, "source", Context.javaToJS(it, scope))
                }
                book?.let {
                    ScriptableObject.putProperty(scope, "book", Context.javaToJS(it, scope))
                }
                chapter?.let {
                    ScriptableObject.putProperty(scope, "chapter", Context.javaToJS(it, scope))
                }
                
                cx.evaluateString(scope, jsCode, "bookSource", 1, null)
                
                if (functionName != null) {
                    val func = scope.get(functionName, scope)
                    if (func is Function) {
                        val jsArgs = args.map { Context.javaToJS(it, scope) }.toTypedArray()
                        val result = func.call(cx, scope, scope, jsArgs)
                        ExecuteResult(
                            success = true,
                            result = Context.jsToJava(result, Any::class.java),
                            executionTime = System.currentTimeMillis() - startTime
                        )
                    } else {
                        ExecuteResult(
                            success = false, 
                            result = null, 
                            error = "函数不存在: $functionName",
                            executionTime = System.currentTimeMillis() - startTime
                        )
                    }
                } else {
                    ExecuteResult(
                        success = true, 
                        result = "OK",
                        executionTime = System.currentTimeMillis() - startTime
                    )
                }
                
            } catch (e: Exception) {
                ExecuteResult(
                    success = false, 
                    result = null, 
                    error = "${e::class.simpleName}: ${e.message}",
                    executionTime = System.currentTimeMillis() - startTime
                )
            } finally {
                Context.exit()
                jsExtensions.clearContext()
            }
        }
        
        return try {
            future.get(30, TimeUnit.SECONDS)
        } catch (e: TimeoutException) {
            future.cancel(true)
            ExecuteResult(
                success = false, 
                result = null, 
                error = "执行超时",
                executionTime = System.currentTimeMillis() - startTime
            )
        } catch (e: Exception) {
            ExecuteResult(
                success = false, 
                result = null, 
                error = e.message,
                executionTime = System.currentTimeMillis() - startTime
            )
        }
    }
    
    // 书源专用方法
    fun executeSearch(source: BookSource, keyword: String): ExecuteResult {
        val searchRule = source.getSearchRule()
        
        if (searchRule.bookList.isNullOrEmpty()) {
            return ExecuteResult(false, null, "搜索规则为空")
        }
        
        val jsCode = buildString {
            appendLine(source.headerJs ?: "")
            appendLine("var key = \"${escapeJsString(keyword)}\";")
            appendLine("var result = ${searchRule.bookList};")
            appendLine("JSON.stringify(result);")
        }
        
        return execute(jsCode, null, source, null, null)
    }
    
    fun executeBookInfo(source: BookSource, book: Book): ExecuteResult {
        val bookInfoRule = source.getBookInfoRule()
        
        if (bookInfoRule.init.isNullOrEmpty()) {
            return ExecuteResult(true, book, executionTime = 0)
        }
        
        val jsCode = buildString {
            appendLine(source.headerJs ?: "")
            appendLine("var book = ${gson.toJson(book)};")
            appendLine("var result = ${bookInfoRule.init};")
            appendLine("JSON.stringify(result);")
        }
        
        return execute(jsCode, null, source, book, null)
    }
    
    fun executeToc(source: BookSource, book: Book): ExecuteResult {
        val tocRule = source.getTocRule()
        
        if (tocRule.chapterList.isNullOrEmpty()) {
            return ExecuteResult(false, null, "目录规则为空")
        }
        
        val jsCode = buildString {
            appendLine(source.headerJs ?: "")
            appendLine("var book = ${gson.toJson(book)};")
            appendLine("var result = ${tocRule.chapterList};")
            appendLine("JSON.stringify(result);")
        }
        
        return execute(jsCode, null, source, book, null)
    }
    
    fun executeContent(source: BookSource, book: Book, chapter: BookChapter): ExecuteResult {
        val contentRule = source.getContentRule()
        
        if (contentRule.content.isNullOrEmpty()) {
            return ExecuteResult(false, null, "正文规则为空")
        }
        
        val jsCode = buildString {
            appendLine(source.headerJs ?: "")
            appendLine("var book = ${gson.toJson(book)};")
            appendLine("var chapter = ${gson.toJson(chapter)};")
            appendLine("var result = ${contentRule.content};")
            appendLine("JSON.stringify(result);")
        }
        
        return execute(jsCode, null, source, book, chapter)
    }
    
    fun testSource(source: BookSource): Map<String, Any> {
        val results = mutableMapOf<String, Any>()
        
        val searchStart = System.currentTimeMillis()
        val searchResult = executeSearch(source, "测试")
        val searchTime = System.currentTimeMillis() - searchStart
        
        results["search"] = mapOf(
            "success" to searchResult.success,
            "time" to searchTime,
            "error" to (searchResult.error ?: "")
        )
        
        if (searchResult.success && searchResult.result != null) {
            try {
                val books = parseSearchResult(searchResult.result)
                if (books.isNotEmpty()) {
                    val bookStart = System.currentTimeMillis()
                    val bookResult = executeBookInfo(source, books[0])
                    val bookTime = System.currentTimeMillis() - bookStart
                    
                    results["bookInfo"] = mapOf(
                        "success" to bookResult.success,
                        "time" to bookTime,
                        "error" to (bookResult.error ?: "")
                    )
                    
                    if (bookResult.success) {
                        val tocStart = System.currentTimeMillis()
                        val tocResult = executeToc(source, books[0])
                        val tocTime = System.currentTimeMillis() - tocStart
                        
                        results["toc"] = mapOf(
                            "success" to tocResult.success,
                            "time" to tocTime,
                            "error" to (tocResult.error ?: "")
                        )
                    }
                }
            } catch (e: Exception) {
                results["bookInfo"] = mapOf(
                    "success" to false,
                    "error" to e.message
                )
            }
        }
        
        return results
    }
    
    // Rhino 1.9.1 配置优化
    private fun configureContext(cx: Context) {
        // 优化级别：-1 解释模式（兼容性最好），9 编译模式（性能最好）
        // 书源兼容性优先，建议用 -1
        cx.optimizationLevel = -1
        
        // Rhino 1.9.1 支持 ES2024/2025
        // VERSION_ES6 或更高版本
        cx.languageVersion = Context.VERSION_ES6
        
        // 最大栈深度，防止栈溢出
        cx.maximumInterpreterStackDepth = 10000
        
        // 指令观察器阈值（用于超时中断）
        cx.setInstructionObserverThreshold(1000000)
        cx.generateObserverCount = true
        
        // Rhino 1.9.1 新特性：启用严格模式支持
        // cx.setStrictMode(true) // 可选，根据需要开启
    }
    
    private fun escapeJsString(str: String): String {
        return str
            .replace("\\", "\\\\")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("\t", "\\t")
    }
    
    private fun parseSearchResult(result: Any?): List<Book> {
        if (result == null) return emptyList()
        
        return try {
            when (result) {
                is String -> {
                    val list = gson.fromJson(result, List::class.java)
                    list?.mapNotNull { item ->
                        if (item is Map<*, *>) {
                            Book(
                                name = (item["name"] as? String)?.trim() ?: "",
                                author = (item["author"] as? String)?.trim() ?: "",
                                bookUrl = (item["bookUrl"] as? String) ?: "",
                                coverUrl = item["coverUrl"] as? String,
                                intro = item["intro"] as? String
                            )
                        } else null
                    } ?: emptyList()
                }
                is List<*> -> {
                    result.mapNotNull { item ->
                        if (item is Map<*, *>) {
                            Book(
                                name = (item["name"] as? String)?.trim() ?: "",
                                author = (item["author"] as? String)?.trim() ?: "",
                                bookUrl = (item["bookUrl"] as? String) ?: "",
                                coverUrl = item["coverUrl"] as? String,
                                intro = item["intro"] as? String
                            )
                        } else null
                    }
                }
                else -> emptyList()
            }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    fun shutdown() {
        executor.shutdown()
        try {
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow()
            }
        } catch (e: InterruptedException) {
            executor.shutdownNow()
        }
    }
}
